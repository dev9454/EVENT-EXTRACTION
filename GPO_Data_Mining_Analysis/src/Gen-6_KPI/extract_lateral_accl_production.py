import numpy as np
import os
import sys
import pandas as pd
import traceback as tb
from openpyxl import load_workbook

if "lin" in sys.platform:
    print('platform :', sys.platform)
    sys.path.append(r'/mnt/usmidet/projects/FCA-CADM/7-Tools')
elif "win" in sys.platform:
    print('platform :', sys.platform)
    sys.path.append(r'C:\Users\pjp8lm\Desktop\Data_Mining_and_analystics\Repos')
from ds_team_tools.hpc_frameworks.utils.mat_file_to_dict import loadmat, load_large_mat_file
from ds_team_tools.hpc_frameworks.utils.support_functions import search_stream


class extractlateralacclproduction:
    """
    Class name and filename needs to be in sync with each other, so that we can dynamically initialize this class.
    Example : file_name = sample_usr_script then class_name needs to be SampleUsrScript
    User should add a general description of what this script does in here.
    **DESCRIPTION**

    functions that user can modify : __init__, run, kpi_sheet_generation, generate_kpi_df.
    functions that user cannot modify : get_func_name, get_headers, get_min_value, get_std, get_mean.
    function that user can uncomment : generate_plot.

    User can add more functions if needed.
    """

    def __init__(self):
        self._func_name = os.path.basename(__file__).replace(".py", "")

        # users to update list of headers as per their requirement.
        # This script supports single sub-sheet or multiple sub-sheet creation as per user's needs.
        # Update the list of headers with the column names you wish to see in the
        # output excel sheet generated by this event finder

        # Begin with "log_path" AND "log_name" in each sheet.

        # Below section can be modified.

        self._headers = dict()
        self._headers['output_sheet'] = ['logPath', 'logName', 'vcan_start_time', 'vcan_end_time', 'engaged_log',
                                         'max_lateral_accel', 'min_lateral_accel', 'absolute_mean_lateral_accel', 'Jerk']

    def get_func_name(self):
        """
        :return: Returns function name
        """
        return self._func_name

    def get_headers(self):
        """
        :return: returns headers
        """
        return self._headers

    # def generate_plot(self):
    #     """
    #     Uncomment this method if output dir value is required for generating plot.
    #     kwargs["plot_dir"] will contain output dir value. kwargs available in run method below.
    #     :return: Boolean True
    #     """
    #     return True

    def get_min_value(self, src_clm: pd.Series) -> float:
        """
        Function returns min value.
        """
        return src_clm.min()

    def get_std(self, src_clm: pd.Series) -> float:
        """
        Function returns std value.
        """
        return src_clm.std()

    def get_mean(self, src_clm: pd.Series) -> float:
        """
        Function returns mean value.
        """
        return src_clm.mean()

    def find_index(self, in_arr, value_to_search):
        """
        A function which find index of value in array without having duplicates value

        param in_arr,value_to_search
        :ret index of value with start index is 0
        """
        for i in range(1, len(in_arr)):
            if in_arr[i - 1] < value_to_search <= in_arr[i]:
                return i
        if in_arr[0] >= value_to_search:
            return 1
        if in_arr[-1] <= value_to_search:
            return len(in_arr) - 1
        else:
            print("error in find index", in_arr, value_to_search)

    def kpi_sheet_generation(self, output_excel_sheet):
        """
        This function will be called from write_excel_to_excel and take out excel as input and add KPI sheet to it.
        :param output_excel_sheet: excel sheet generated after reducer.
        :return:
        """
        # Below section can be modified.

        # Define KPI dataframe, first three columns should be "Parameter", "KPI metric", "KPI metric units".
        # You can add more columns if required.
        # ['logPath', 'loogName','max_tx1','max_tx2','max_tx3','total_max']
        output_df = pd.read_excel(output_excel_sheet, sheet_name='output_sheet')
        kpi_df = pd.DataFrame()
        # [logPath,logName,max_lateral_accel,min_lateral_accel,mean_lateral_accel]
        kpi_df['min_lateral_accl'] = np.max(np.array(output_df['max_lateral_accel']))
        kpi_df['max_lateral_accl'] = np.min(np.array(output_df['min_lateral_accel']))
        kpi_df['mean_lateral_accl'] = np.mean(np.array(output_df['mean_lateral_accel']))

        # Avoid modifying this part
        book = load_workbook(output_excel_sheet)
        writer = pd.ExcelWriter(output_excel_sheet, engine='openpyxl')
        writer.book = book
        writer.sheets = {x.title: x for x in book.worksheets}
        kpi_df.to_excel(writer, index=False, sheet_name="KPI")
        writer.save()
        writer.close()

    def run(self, file_name, **kwargs):
        ##Mandatory details for th script ##
        """
        Description: Write briefly about your script
        Input to the script: filelist with file names
        Input file type: .mat or .mudp
        Output of the script: Excel sheet with events

        """
        # Below section can be modified.
        global ctime
        try:
            output_sheet = list()
            logPath, logName = os.path.split(file_name)
            try:
                self.data = loadmat(file_name)
            except Exception as e:
                self.data = load_large_mat_file(file_name)
            lc_status = np.array(
                self.data['mudp']['inst']['LC']['LC_SAF_Msg']['LCStatus'])  # mudp.inst.LC.LC_SAF_Msg.LCStatus
            inst_ctime = np.array(self.data['mudp']['inst']['LC']['header']['cTime'])
            lateral_accel = np.array(self.data['mudp']['VSE']['vcan']['LatAcceleration'])
            vcan_ctime = np.array(self.data['mudp']['VSE']['header']['cTime'])
            lc_enaged = False
            event_exist = False
            all_log_engagment = False
            if np.sum(lc_status == 3) == len(lc_status):
                all_log_engagment = True

            events_index_list = []
            lc_index_list = []
            if all_log_engagment == True:
                vcan_ctime_start = vcan_ctime[0]
                vcan_ctime_end = vcan_ctime[-1]
                max_lateral_accel = np.max(lateral_accel)
                min_lateral_accel = np.min(lateral_accel)
                mean_lateral_accel = np.mean(np.absolute(lateral_accel))
                jerk = sum((np.absolute(lateral_accel) > 5)) > 1  # threshold for jerk
                output_sheet.append(
                    [logPath, logName, vcan_ctime_start, vcan_ctime_end, all_log_engagment, round(max_lateral_accel, 3),
                     round(min_lateral_accel, 3),
                     round(mean_lateral_accel, 3), jerk])

            else:
                for i in range(len(lc_status)):
                    if lc_status[i] == 3 and lc_enaged == False:
                        lc_enaged = True
                        engaged_ctime_start = inst_ctime[i]
                        engaged_vcan_ctime_index_start = self.find_index(vcan_ctime, engaged_ctime_start)
                    elif lc_status[i] != 3 and lc_enaged == True:
                        lc_enaged = False
                        engaged_ctime_end = inst_ctime[i - 1]
                        engaged_vcan_ctime_index_end = self.find_index(vcan_ctime, engaged_ctime_end)
                        event_exist = True
                    elif lc_enaged == True and i == len(lc_status) - 1:
                        lc_enaged = False
                        event_exist = True
                        engaged_ctime_end = inst_ctime[i]
                        engaged_vcan_ctime_index_end = self.find_index(vcan_ctime, engaged_ctime_end)
                    else:
                        pass
                    if event_exist == True:
                        lc_index_list.append([engaged_ctime_start,engaged_ctime_end])
                        events_index_list.append([engaged_vcan_ctime_index_start, engaged_vcan_ctime_index_end])
                        event_exist = False
                    else:
                        pass
                events_index_list = np.unique(np.array([np.sort(sub) for sub in events_index_list]), axis=0)
                lc_index_list = np.unique(np.array([np.sort(sub) for sub in lc_index_list]), axis=0)
                if len(events_index_list) != 0:
                    for i in events_index_list:
                        event_start_index = i[0]
                        event_end_index = i[-1]
                        vcan_ctime_start = vcan_ctime[event_start_index]
                        vcan_ctime_end = vcan_ctime[event_end_index - 1]
                        temp_accel_array = np.array(lateral_accel[event_start_index:event_end_index])
                        max_lateral_accel = np.max(temp_accel_array)
                        min_lateral_accel = np.min(temp_accel_array)
                        mean_lateral_accel = np.mean(np.absolute(temp_accel_array))
                        jerk = sum((np.absolute(temp_accel_array) > 5)) > 1
                        output_sheet.append([logPath, logName, vcan_ctime_start, vcan_ctime_end, all_log_engagment,
                                             round(max_lateral_accel, 3), round(min_lateral_accel, 3),
                                             round(abs(mean_lateral_accel), 3), jerk])
            out = dict()
            # Sheet name needs to match with sheet_name in self._headers
            # Make sure header column count matches with output column count
            out['output_sheet'] = np.array(output_sheet)
            return out

        except Exception:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            print(str(tb.format_exc()))
            return str(exc_obj.args[0]) + " FOUND IN LINE: " + str(exc_tb.tb_lineno)


if __name__ == '__main__':
    kwargs = dict()
    path = r"C:\Users\pjp8lm.APTIV\Downloads"
    file_name = r"C:\Users\pjp8lm\Desktop\Data_Mining_and_analystics\ADAS_247_Prod\STEL\FCAWL_20220503_RGVIN646_ChkOut_RG34R7_TRY_CHI_MN_OR_153947_057_rC02_rTR45001321_rD4200090049hc5R"
    Test = extractlateralacclproduction()
    cell = Test.run(file_name, **kwargs)
    print(cell)
# dvlExtDBC.LRR.LRRF1_Status_Temp_Volt.LRRF1_CAN_Dolphin_Tx1
#
# dvlExtDBC.LRR.LRRF1_Status_Temp_Volt.LRRF1_CAN_Dolphin_Tx2
#
# dvlExtDBC.LRR.LRRF1_Status_Temp_Volt.LRRF1_CAN_Dolphin_Tx3
